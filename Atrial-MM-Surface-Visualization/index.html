<!DOCTYPE html>
<html lang="en">
<head>
    <title>MM</title>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />

<!-- Online libraries and dependencies -->
<script src='https://kaboudian.github.io/abubujs/libs/Abubu.latest.js'
	    type='text/javascript'></script>
<script 
src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/ace.js'  
type="text/javascript" charset="utf-8">
</script>
<script 
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/mode-glsl.js'>
</script>
<script 
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/theme-tomorrow.js'>
</script>
<script
    src='https://cdnjs.cloudflare.com/ajax/libs/ace/1.4.5/keybinding-vim.js'>
</script>
<script 
    src="https://ajax.googleapis.com/ajax/libs/jquery/3.4.1/jquery.min.js">
</script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.6.0/jszip.min.js"></script>

<!-- Add this in the head section, after the existing scripts -->
<script src="https://cdn.jsdelivr.net/npm/webxr-polyfill@latest/build/webxr-polyfill.min.js"></script>

<style>

/* unvisited link */
a:link {
    	color: blue;
}

/* visited link */
a:visited {
    	color: blue;
}

/* mouse over link */
a:hover {
    	color: hotpink;
}

/* selected link */
a:active {
    	color: blue;
}
/*
li{
    	margin : 10px 6px ;
} */

body {
	counter-reset: h1;
}


h1{
        max-width: 1024px ;
	text-align:left;
	color: white;
       	background-color: #00254c;
       	padding-left: 20px ;
       	padding-top: 10px ;
       	padding-bottom: 10px ;
       	border-radius: 10px;
}

h2 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #e5e5e5 ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;

    	border-radius: 10px;
}

h3 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #f0f0f0 ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;
    	border-radius: 10px;
}

h4 {
        max-width: 1024px ;
    	color: #00254c;
    	background-color: #fafafa ;
    	padding-left: 20px ;
    	padding-top: 2.5px ;
    	padding-bottom: 2.5px ;
    	border-radius: 10px;
}

p{
    max-width : 700px  ;
    padding-left: 10px ;
}
canvas.clickable:hover{
    cursor:pointer ;
    cursor:hand ;
}

.footer{
    position : fixed ; 
    max-width: 1024px ;
    border-radius:10px ;
    left : 0px ;
    width : 100% ;
    background-color: #fafafa;
    color:black ;
    bottom: 0px ;
    text-align : left ;
    font: 'italic 12pt Times' ;
}


div.relative {
  position: relative;
  height: 512px;
  border: 1px solid black;
  width:100% ;
} 

div.editor {
  position : absolute;
  top: 0px;
  right: 0;
  bottom: 0;
  left: 0;
  width:100%;
}
#loading { 
    position : fixed ;
    bottom : 20px ;
    left : 10px ;
}
#loadProgress {
    width : 300px ;
    background-color: #ddd ;
}
#loadBar {
    width : 0% ;
    height : 20px ;
    background-color: #4caf50 ;
    border-radius: 3px ;
}

</style>


</head>
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- body of the html page                                             -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<body>
    <h1>Patient Specific Minimal Model</h1>
    
    <div id='chooser'>
        <h2>Select the JSON file containing the structure</h2>
        <p style='color:red'>Before you can proceed, you need to choose the structural
        file!</p>
       <input type='file' id='json_structure' accept='.json, .JSON'></input>
    </div> 
    <table>
 
        </tr>
        <tr>
            <td>
                <canvas id=canvas_1 width=512 height=512>
                    Your browser doesn't support HTML5.0
                </canvas>
            </td>
            <td>
                <canvas id=canvas_2 width=512 height=512>
                    Your browser doesn't support HTML5.0
                </canvas>
            </td>
        </tr>
    </table>
<div class='loaded'>
    <h3>Instructions for modifiable sections.</h3>
<p>You can edit the source code for a number of the modeling shaders by accessing the <b>Edit/Save/Load Source Code</b> menu of the GUI. As soon as the shader is edited, the program automatically starts using the updated version of the code.</p>

<p>Notice that GLSL does not allow for mixing of data types. So, floats
and integers cannot be mixed unless directly type casted.</p>

    <div class='relative' id='editorSection' style='display:none'>
        <h2>Source code editor</h2>
        <div class='editor' id='editor'></div>
    </div>

</div>   
    
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- All shaders included here (codes written in GLSL)                 -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- ***************************************************************** -->
<script id='directionator' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * directionator.frag : find North, South, East, West, Up and Down
 * dirction indices 
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )


/*-------------------------------------------------------------------------
 * interfacial variables
 *-------------------------------------------------------------------------
 */
in vec2 cc ;

uniform usampler2D fullTexelIndex, compressedTexelIndex ;
uniform int mx, my ;

/*------------------------------------------------------------------------
 * output colors
 *------------------------------------------------------------------------
 */
layout (location = 0) out uvec4 odir0 ;
layout (location = 1) out uvec4 odir1 ;

/*========================================================================
 * getIJ: return the IJ index on the full 2d-matrix
 *========================================================================
 */
ivec2 getIJ(ivec3 idx, ivec3 size){
    int si = idx.z % mx ;
    int sj = idx.z / mx ;

    return ivec2(size.x*si + idx.x, (my-1-sj)*size.y + idx.y) ;
}

/*========================================================================
 * getIdx: get the 3d index from the IJ indices
 *========================================================================
 */
ivec3 getIdx( ivec2 IJ, ivec3 size ){
    int si = IJ.x / size.x ;
    int sj = (my - 1) - (IJ.y/size.y) ;

    return ivec3( IJ.x % size.x, IJ.y % size.y , mx*sj + si ) ;
}

/*========================================================================
 * macros 
 *========================================================================
 */
#define isInBounds( v )     (all(greaterThanEqual(v,ivec3(0))) && \
        all(lessThan(v,size)))

#define texelInDomain(I)  ( texelFetch(compressedTexelIndex,(I),\
            0).a==uint(1) )
#define inDomain( v )   (texelInDomain( getIJ(v, size) )) 
#define isNotGood(v)   (!( inDomain(v) && isInBounds( v ) ))

/*========================================================================
 * getPackedIndex: get packed index of the point by applying the zero-flux
 * condition.
 *========================================================================
 */
uint getPackedIndex( ivec3 C, ivec3 D, ivec3 size ){
    ivec3 checkPoint = C+D ;
    
    if ( isNotGood(checkPoint) ){ /* if that direction is not good move in
                                     the opposite direction */
        checkPoint = C-D ;
        if ( isNotGood( checkPoint ) ){ /* if the opposite direction is
                                           not good either, use the
                                           central point coordinate */
            checkPoint = C ;
        }
    }
    uvec2 targetIndex = texelFetch(
            compressedTexelIndex,
            getIJ(checkPoint,size),
            0 ).xy ;
    return pack(targetIndex.x,targetIndex.y) ;  
}

/*========================================================================
 * main
 *========================================================================
 */
void main(){
    // get the sizes of the compressed and the full domain ...............
    ivec2 compSize = textureSize(fullTexelIndex,        0 ) ;
    ivec2 fullSize = textureSize(compressedTexelIndex,  0 ) ;

    // calculate the resolution of the full domain .......................
    ivec3 size = ivec3( fullSize.x/mx , fullSize.y/my, mx*my ) ;

    // get the textel position and full texel index ......................
    ivec2 texelPos = ivec2( cc*vec2(compSize) ) ; 
    ivec4 fullTexelIndex = 
        ivec4( texelFetch(  fullTexelIndex, texelPos, 0) ) ;

    // if the texel is extra, just leave .................................
    if ( fullTexelIndex.a != 1 ){
        return ;
    }
    
    // 3-dimentional index of the of texel ...............................
    ivec3 cidx = getIdx( fullTexelIndex.xy , size ) ;

    // diretionional vectors .............................................
    ivec3 ii = ivec3(1,0,0) ;
    ivec3 jj = ivec3(0,1,0) ;
    ivec3 kk = ivec3(0,0,1) ;

    // calculating the packed indices of the each compute point ..........
    uvec4 dir0 , dir1 ;
   
    NORTH = getPackedIndex( cidx, jj, size) ; // north direction
    SOUTH = getPackedIndex( cidx,-jj, size) ; // south direction
    EAST  = getPackedIndex( cidx, ii, size) ; // east  direction
    WEST  = getPackedIndex( cidx,-ii, size) ; // west  direction

    UP    = getPackedIndex( cidx, kk, size) ; // up   direction
    DOWN  = getPackedIndex( cidx,-kk, size) ; // down direction

    // outputing the calculated points ...................................
    odir0 = uvec4(dir0) ;
    odir1 = uvec4(dir1) ;

    return ;
}
</script><!-- end of directionator shader's source code -->

<!-- ***************************************************************** -->
<script id='init' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * init.frag    : initialize the solution
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


// interfacial variables .................................................
in vec2 cc ;
uniform sampler2D   compressed3dCrdt ;

// output colors .........................................................
layout (location  = 0) out vec4 ocolor0 ;

// color macros ..........................................................
#define U   color0.r
#define V   color0.g
#define W   color0.b
#define D   color0.a

#define vlt_txtr icolor0
#define vchannel r


/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    vec4 color0 ;

    // 3d coordinate of the texel
    vec3 crd = texture(compressed3dCrdt , cc).xyz ;

    U = 0.01 ;
    V = 1. ;
    W = 1. ;
    D = 0.03 ;

  //  if ( crd.z <0.3 ){
  //      if ( crd.x >0.25 && crd.x<0.3)
  //          U = 1. ;
  //      if ( crd.x >0.3 && crd.x<0.4)
  //          V = 0. ;
  //  }

    ocolor0 = vec4(color0) ;
}
</script><!-- end of init shader's source code -->

<!-- ***************************************************************** -->
<script id='comp' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * comp.frag    : time-stepping shader
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */

precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


in vec2 cc  ;
uniform float   dt ;        // time increment
uniform float   lx ;        // domain length
uniform int     resolution ;// resolution in all directions
uniform int     mx, my ;    /* number of z-layers in S and T directions 
                               of the textures */

// directional information ...............................................
uniform usampler2D  idir0 ;
uniform usampler2D  idir1 ;

/*========================================================================
 * all direction macros go here for safe access
 *========================================================================
 */
#define NORTH   dir0.r
#define SOUTH   dir0.g
#define EAST    dir0.b
#define WEST    dir0.a

#define UP      dir1.r
#define DOWN    dir1.g

/*========================================================================
 * packing and unpacking two integers to and from a single unsigned int.
 *========================================================================
 */
#define pack(i,j)   uint((uint(i)<<16)+uint(j))
#define unpack(I)   ivec2(uint(I)>>16, uint(I) & uint(65535) )



// coordinate of the system ..............................................
uniform sampler2D   compressed3dCrdt ;

uniform sampler2D   icolor0 ;

// patient data ..........................................................
uniform float   u_c  , u_v  , u_w  , u_d  , t_vm , t_vp , t_wm , t_wp ,
                t_sp , t_sm , u_csi, x_k  , t_d  , t_o  , t_soa, t_sob,
                u_so , x_tso, t_si , t_vmm, diffCoef , C_m ;

#define  u_0  0. 
#define  u_m  1.0 
#define  u_na 0.23 

#define U   color0.r
#define V   color0.g
#define W   color0.b
#define D   color0.a

#define vlt_txtr icolor0
#define vchannel r


// output color ..........................................................
layout ( location = 0 ) out vec4 ocolor0 ;

/*========================================================================
 * Approximate hyperbolic tangent 
 *========================================================================
 */
float Tanh(float x){
    if ( x<-3.0){
        return -1.0 ;
    } else if (x>3.0){
        return 1.0 ;
    } else {
        return x*(27.0 + x*x)/(27.0+9.0*x*x) ;
    }
}

/*========================================================================
 * main body of the shader
 *========================================================================
 */
void main(){
    // extract pixel values from textures ................................
    ivec2 isize = textureSize(icolor0,        0 ) ;
    ivec2 texelPos = ivec2( cc*vec2(isize) ) ; 
    
    // localizing color values ...........................................
    vec4    color0 = texelFetch(icolor0, texelPos, 0) ;
    
    // directional channels ..............................................
    uvec4 dir0  = texelFetch(idir0 , texelPos, 0 ) ;
    uvec4 dir1  = texelFetch(idir1 , texelPos, 0 ) ;


    // step functions ....................................................
    float   H_u_na  = ( U > u_na    )   ?   1.0 : 0.0 ;
    float   H_u_v   = ( U > u_v     )   ?   1.0 : 0.0 ;
    float   H_u_w   = ( U > u_w     )   ?   1.0 : 0.0 ;
    float   H_u_d   = ( U > u_d     )   ?   1.0 : 0.0 ;
    float   H_u_c   = ( U > u_c     )   ?   1.0 : 0.0 ;

    // I_fi ..............................................................
    float   I_fi = -V*(U-u_na)*(u_m-U)*H_u_na/t_d ;

    // I_so ..............................................................
    float   t_so = t_soa + 0.5  *(t_sob - t_soa)
                                *(1.0 + Tanh((U-u_so)*x_tso)    ) ;

    float   I_so = (U-u_0)*(1.-H_u_c)/t_o + H_u_c/t_so ;

    // I_si ..............................................................
    float   I_si = -W*D/t_si ;
   
    // I_sum .............................................................
    float I_sum = I_fi+I_so+I_si ;

    // V .................................................................
    float   dV2dt = (1. - H_u_na)*(1.-V)/((1.-H_u_v)*t_vm + H_u_v*t_vmm )
                - H_u_na*V/t_vp ;
    V += dV2dt*dt ;

    // W .................................................................
    float   dW2dt = (1.-H_u_w)*(1.-W)/t_wm - H_u_w*W/t_wp ;
    W += dW2dt*dt ;

    // D .................................................................
    float   dD2dt = (  (1.-H_u_d)/t_sm + H_u_d/t_sp         )*
                    (  (1. + Tanh(x_k*(U-u_csi)))*0.5 - D   ) ;
    D += dD2dt*dt ;

   
    // laplacian .........................................................
    float  dx = lx/float(mx*my) ;

    float laplacian = (
            texelFetch( vlt_txtr, unpack( NORTH ), 0 )
        +   texelFetch( vlt_txtr, unpack( SOUTH ), 0 )
        +   texelFetch( vlt_txtr, unpack( EAST  ), 0 )
        +   texelFetch( vlt_txtr, unpack( WEST  ), 0 )
        +   texelFetch( vlt_txtr, unpack( UP    ), 0 )
        +   texelFetch( vlt_txtr, unpack( DOWN  ), 0 )
        -6.*texelFetch( vlt_txtr, texelPos, 0 )         ).vchannel ;

    laplacian = laplacian/(dx*dx) ;

    
    // U .................................................................
    float dU2dt = laplacian*diffCoef - I_sum/C_m ;
    U += dU2dt*dt ;

    // ouput updated color ...............................................
    ocolor0 = vec4(color0) ;
    return ;
}
</script><!-- end of comp shader's source code -->

<!-- ***************************************************************** -->
<script id='click' type='x-shader-fragment'>#version 300 es
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * click.frag   : Excite the region that is clicked
 *
 * PROGRAMMER   : ABOUZAR KABOUDIAN
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
precision highp float;
precision highp int ;
precision highp isampler2D ;
precision highp usampler2D ;


// interfacial variables .................................................
in vec2 cc ;

uniform sampler2D   icolor0 ;
uniform sampler2D   compressed3dCrdt ;

uniform sampler2D   projectedCoordinates ;
uniform vec2        clickPosition ;

uniform float       clickRadius ;

// output color ..........................................................
layout (location = 0) out vec4 ocolor0 ;

#define U   color0.r
#define V   color0.g
#define W   color0.b
#define D   color0.a

#define vlt_txtr icolor0
#define vchannel r


/*========================================================================
 * main
 *========================================================================
 */
void main(){
    vec4 color0 = texture( icolor0 , cc ) ;
    vec3 texelCrdt = texture(compressed3dCrdt, cc ).xyz ;
    vec3 clickCrdt = texture(projectedCoordinates, clickPosition ).xyz ; 

    if (length(texelCrdt - clickCrdt )<clickRadius ){
        U = 1. ;
    }

    ocolor0 = vec4(color0) ;
    return ;
}
</script><!-- end of click shader's source code -->


<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<!-- main script - JavaScript code                                     -->
<!--&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&-->
<script>
/*@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 * WEBGL 2.0    :   Minimal Atrial Model 
 *
 * PROGRAMMER   :   ABOUZAR KABOUDIAN
 * DATE         :   Fri 03 Sep 2021 17:37:27 (EDT)
 * PLACE        :   Atlanta, GA
 *@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@
 */
"use strict" ;

/*========================================================================
 * get the source code for fragment shaders
 *========================================================================
 */
function source( id ){
    return document.getElementById( id ).innerHTML ;
}
/*========================================================================
 * Global Parameters
 *========================================================================
 */
let env = {} ;

/*========================================================================
 * import surface data
 *========================================================================
 */
let loadedJSON ;

/*========================================================================
 * let the user select the file
 *========================================================================
 */
var fileInput = document.getElementById('json_structure') ;

fileInput.onchange = function(){
  let file = fileInput.files[0] ;
  if ( !file ){
      return ;
  }
  let reader = new FileReader() ;
  reader.readAsText(file) ;

  reader.onload = function(e){
      let result = e.target.result ;
      loadedJSON = JSON.parse(result) ;
      $('#chooser').hide() ;
      $('.loaded').show() ;
      loadWebGL() ;
  } ;
}

var gl = Abubu.gl ;

/*========================================================================
 * Read structure from file on the server for debugging purposes
 * NOTE: if not debugging comment out this section
 *========================================================================
 */
//let structureFile = new XMLHttpRequest();
//
//structureFile.onreadystatechange = () => {
//    if (structureFile.readyState == 4 && structureFile.status == 200) {
//        loadedJSON = JSON.parse(structureFile.responseText);
//        console.log(loadedJSON) ;
//        $('#chooser').hide() ;
//        $('.loaded').show() ;
//
//        loadWebGL() ;
//    }
//};
//console.log("324") ;
//structureFile.open("GET", 
//        "/jsons/AtrialExamples/02-350um-192x192x192_lra_grid.json", true);
//structureFile.send();
//

/*========================================================================
 * WallTime
 *========================================================================
 */
class WallTimer{
    constructor(opts={}){
        this._duration  = opts?.duration ?? 100 ; /* duration of the
                                        measurements in miliseconds of
                                        simulated electrical activity   */
        this._start     = opts?.start ?? 0 ; /* physical time of the
                                                measurements            */
                                             
        this._startTime = new Date().getTime() ;    /* start wall-time of
                                                       the measurements */
        this._endTime   = NaN ;
        this._started   = false;    /* flag that wall-time 
                                       measurements have started        */
        this._finished  = false ;   /* flag indicating if wall-time
                                       measurements have ended          */
        this._paused    = false ;    /* flag indicating if measurements 
                                       are paused                       */
        this._lapsedTime= 0 ;       /* lapsed time of the wall-time
                                       measurements                     */
    }// end of constructor ...............................................

/*------------------------------------------------------------------------
 * getters and setters of the class
 *------------------------------------------------------------------------
 */
    get duration(){
        return this._duration ; 
    }

    set duration(v){
        this._duration = v ;
        this.reset() ;
    }

    get paused(){
        return this._paused ;
    }

    set paused(v){
        if (v & !this.paused & !this.finished){
            this.endTime = new Date().getTime() ;
            this._started = false ;
            this._lapsedTime += (this.endTime - this.startTime) ;
            this._paused = v ;
        }else if ( !v ){
            this._paused = v ;
        }
        return ;
    }
    
    get start(){
        return this._start ;
    }

    set start(v){
        this._start = v ;
    }

    get startTime(){
        return this._startTime ;
    }

    set startTime(v){
        this._startTime = v ;
    }

    get endTime(){
        return this._endTime ;
    }

    set endTime(v){
        this._endTime =v  ;
    }

    get lapsedTime(){
        return this._lapsedTime ;
    }

    get finished(){
        return this._finished ;
    }
    set finished(v){
        this._finished = v ;
    }

    get started(){
        return this._started ;
    }

    set started(v){
        this._started = v ;
    }

    get end(){
        return this.start + this.duration ;
    }

    get progress(){
        if (this.finished) return 100 ;
        return Math.round(100*( env.time - this.start)/this.duration) ;
    }

/*------------------------------------------------------------------------
 * Methods
 *------------------------------------------------------------------------
 */
    // Measure wall-time .................................................
    measure(){
        if ( !env.running & !this.paused ){
            this.paused  = true ;
            return ;
        }
        if ( !env.running ) return ;

        if ( !this.started & !this.paused & env.time >= this.start ){
            this.started = true ;
            this.startTime = new Date().getTime() ; 
            return ;
        }
        
        if ( !this.finished & !this.paused & env.time >= this.end ){
            this.finished = true ;
            this._endTime = new Date().getTime() ;
            this._lapsedTime += (this.endTime - this.startTime) ;
        }
    }

    // Reset measurements ................................................
    reset(){
        this._started       = false ;
        this.start          = env.time ;
        this._finished      = false ;
        this._lapsedTime   = 0 ;
    }
}

/*========================================================================
 * Initialization of the GPU and Container
 *========================================================================
 */
function loadWebGL()
{
    env.allFloats   = [] ; // uniform shared floats
    env.allInts     = [] ; // uniform shared integers
    env.allTxtrs    = [] ; // uniform shared textures

/*------------------------------------------------------------------------
 * display parameters
 *------------------------------------------------------------------------
 */
    env.colormap    = 'rainbowHotSpring' ;
    env.dispWidth   = 512 ;
    env.dispHeight  = 512 ;

    env.canvas_1 = document.getElementById("canvas_1") ;
    env.canvas_2 = document.getElementById("canvas_2") ;
    env.canvas_1.width  = env.dispWidth ;
    env.canvas_1.height = env.dispHeight ;

/*------------------------------------------------------------------------
 * load the structure and process it
 *------------------------------------------------------------------------
 */
    env.loadedJSON = loadedJSON ;
    env.mx = loadedJSON.mx ; env.my = loadedJSON.my ;
    env.allInts = [...env.allInts, 'mx','my' ] ;

    env.structure = new Abubu.StructureFromJSON( loadedJSON ) ;

    env.width                   = env.structure.width ;
    env.height                  = env.structure.height ;
    env.fwidth                  = env.structure.fwidth ; 
    env.fheight                 = env.structure.fheight ;

    env.fullTexelIndex          = env.structure.fullTexelIndex ;
    env.compressedTexelIndex    = env.structure.compressedTexelIndex ;
    env.full3dCrdt              = env.structure.full3dCrdt ;
    env.compressed3dCrdt        = env.structure.compressed3dCrdt ;
    env.normals                 = env.structure.normals ;

    env.loaded = true ;

    env.allTxtrs = [...env.allTxtrs, 'compressed3dCrdt' ] ;  
    

/*------------------------------------------------------------------------
 * zero-flux directionator 
 *------------------------------------------------------------------------
 */
    env.dir0 = new Abubu.Uint32Texture( env.width, env.height ) ;
    env.dir1 = new Abubu.Uint32Texture( env.width, env.height ) ;

    env.idir0 = env.dir0 ;
    env.idir1 = env.dir1 ;

    env.directionator = new Abubu.Solver({
        fragmentShader : source('directionator') ,
        uniforms : {
            mx : { type : 'i' , value : env.mx } ,
            my : { type : 'i' , value : env.my } ,
            fullTexelIndex : { 
                type : 't', value : env.fullTexelIndex 
            } ,
            compressedTexelIndex : { 
                type : 't', value : env.compressedTexelIndex
            } ,
        },
        targets: {
            odir0 : { location : 0, target : env.dir0 } ,
            odir1 : { location : 1, target : env.dir1 } ,
        }
    } ) ;
    env.directionator.render() ; 

    env.allTxtrs = [...env.allTxtrs, 'idir0', 'idir1' ] ;


/*------------------------------------------------------------------------
 * textures for time-stepping
 *------------------------------------------------------------------------
 */
    env.fcolors = [] ;
    env.scolors = [] ;

    for(let i=0; i<1; i++){
        env['fcolor'+i] = new Abubu.Float32Texture( 
                env.width, env.height, { pairable : true } ) ;
        env['scolor'+i] = new Abubu.Float32Texture( 
                env.width, env.height, { pairable : true } ) ;
        env.fcolors.push(env['fcolor'+i]) ;
        env.scolors.push(env['scolor'+i]) ;
    }
    env.colors = [ ...env.fcolors, ...env.scolors ] ;

/*------------------------------------------------------------------------
 * init solvers
 *------------------------------------------------------------------------
 */
    // init. .............................................................
    class InitTargets{
        constructor( colors ){
            for(let i=0; i<1 ; i++){
                this["ocolor"+i] = {location : i, target: colors[i]} ;
            }
        }
    }
    env.finit = new Abubu.Solver({
        fragmentShader : source('init') ,
        uniforms : { 
            compressed3dCrdt : { type : 't', value : env.compressed3dCrdt }
        } ,
        targets : new InitTargets( env.fcolors ) ,
    } ) ;

    env.sinit = new Abubu.Solver({
        fragmentShader : source('init') ,
        uniforms : { 
            compressed3dCrdt : { type : 't', value : env.compressed3dCrdt }
        } ,
        targets : new InitTargets( env.scolors ) ,
    } ) ;

/*-------------------------------------------------------------------------
 * model parameters 
 *-------------------------------------------------------------------------
 */
    class Patient{
        constructor(no){
            this.floats = [ 
                'u_c' , 'u_v' , 'u_w' , 'u_d' , 't_vm', 't_vp', 't_wm', 
                't_wp', 't_sp', 't_sm', 'u_csi','x_k' , 't_d' , 't_o' , 
                't_soa','t_sob','u_so' ,'x_tso','t_si' ,'t_vmm', 
                'diffCoef' ] ;
            this.list = [ 'Patient 1', 'Patient 1-Alt','Patient 2',
                     'Patient 3', 'Patient 4', 'Patient 5', 'Original' ] ;
            this.number = no ;

        } // end of constructor

        get number(){
            return this._no ;
        }
        set number(no){
            this._no = no ;
            switch (this.number){
                case 0: // patient 1
                    this._value = [
                        0.1313 , 0.3085 , 0.2635 , 0.05766, 57.12  ,
                        2.189  , 68.50  , 871.4  , 1.110  , 1.7570 ,
                        0.1995 , 6.043  , 0.12990, 15.17  , 72.66  ,
                        7.933  , 0.4804 , 2.592  , 40.11  , 1012 ,
                        1.611E-03 ] ;
                    break ;
                case 1: // patient 1-alt
                    this._value = [
                        0.2171 , 0.1142 , 0.2508 , 0.1428 , 46.77  ,
                        1.759  , 80.18  , 749.5  , 1.484  , 1.983  ,
                        0.2168 , 21.62  , 0.08673, 17.05  , 54.90  ,
                        1.685  , 0.6520 , 2.161  , 38.82  , 1321   ,
                        1.337E-03 ] ;
                    break ;
                case 2: // patient 2
                    this._value = [
                        0.2579  , 0.1799, 0.2566 , 0.1943 , 40.31  ,
                        1.349   , 89.08 , 777.0 ,  1.144 ,  1.086  , 
                        0.2722  , 6.142 , 0.04456, 23.45 ,  97.89  , 
                        3.308   , 0.4185, 1.997  , 36.60 ,  1183   , 
                        1.405E-03 ] ; 
                    break ;
                case 3 :
                    this._value = [
                        0.2131  , 0.1107, 0.2798,   0.1601 ,    35.75 ,
                        1.247   , 109.8 , 751.8 ,   1.487,      2.241 ,
                        0.2097  , 8.679 , 0.06880 , 18.31,      54.43 ,
                        4.894   , 0.6804, 2.187   , 40.39,      1187  ,
                        1.704E-03 ] ;
                    break ;
                case 4 :
                    this._value = [
                        0.2069   ,0.03489  ,0.1788   ,3.140E-04,971.3    ,
                        2.243    ,110.7    ,616.0    ,16.29    ,7.104E-03,
                        0.1682   ,8.958    ,0.08511  ,6.754    ,152.9    ,
                        19.82    ,6.013E-03,8.677    ,18.94    ,120.5    ,
                        2.696E-03 ] ;
                    break ;
                case 5 :
                    this._value = [
                        0.2588 ,0.1382 ,0.2589 ,0.1797 ,45.15  ,
                        2.194  ,166.4  ,836.3  ,1.315  ,0.764  ,
                        0.2023 ,7.351  ,0.06711,18.28  ,105.4  ,
                        3.264  ,0.3497 ,1.968  ,39.23  ,1166   ,
                        8.479E-04 ] ;
                    break ;
                default : // original model
                    this._value = [
                        0.1300 ,0.04000, 0.1300 , 0.1300 , 19.60  , 
                        3.330  ,41.00  , 870.0  , 1.000  , 1.000  , 
                        0.8500 ,10.00  , 0.2500 , 12.50  , 33.30  , 
                        33.30  ,0.8500 , 10.00  , 29.00  , 1250   , 
                        1.000E-3 ] ;
                    break ;
            } // end of switch statement
            for(let i in this.floats){
                let name  = this.floats[i] ;
                env[name] = this._value[i] ;
            }
        }// end of set number

        get name(){
            return this.list[this.number] ;
        }
        set name(n){
            for(let i=0; i < this.list.length; i++){
                if(this.list[i] == n){
                    this.number = i ;
                }
            }
        }
        updateSolvers(){
            for(let name of this.floats){
                env.fcomp.uniforms[name].value = env[name] ;
                env.scomp.uniforms[name].value = env[name] ;
            }
        }
    } ;
 
    env.patient = new Patient(1) ;
    env.allFloats = [ ...env.allFloats,...env.patient.floats] ; 

/*------------------------------------------------------------------------
 * defining the environments initial values 
 *------------------------------------------------------------------------
 */
    env.running     = false ;
    env.dt          = 0.05 ;
    env.C_m         = 1. ;
    if (loadedJSON?.length){
        env.lx = loadedJSON.length/10 ;
    }else{
        env.lx = 8.  ;
    }
    env.resolution  = 128 ;
    env.skip        = 10 ;
    env.time        = 0. ;
    
    env.allFloats   = [...env.allFloats, 'dt','C_m' ,'lx' ] ; 
    env.allInts = [...env.allInts, 'resolution' ] ;

/*------------------------------------------------------------------------
 * Common CompUniforms
 *------------------------------------------------------------------------
 */
    class CompGeneralUniforms{
        constructor( obj, floats, ints, txtrs){
            for(let name of floats ){
                this[name]  = { type :'f', value : obj[name] } ;
            }
            for(let name of ints){
                this[name]  = { type : 'i', value : obj[name] } ;
            }
            for(let name of txtrs){
                this[name] = { type : 't', value : obj[name] } ;
            }
        }
    }

    // comp .............................................................
    class CompUniforms extends CompGeneralUniforms{
        constructor( _fc, _sc ){
            super(env, env.allFloats, env.allInts, env.allTxtrs ) ;
            for(let i =0 ; i <1 ; i++){
                this['icolor'+i] = { type: 't', value : _fc[i] } ;
            }
        }
    }

    class CompTargets{
        constructor( _fc,_sc ){
            for(let i=0; i<1 ; i++){
                let j = i ;
                this['ocolor'+i] = {location : i, target : _sc[j] } ;
            }
        }
    }

    env.fcomp = new Abubu.Solver({
        fragmentShader : source('comp') ,
        uniforms : new CompUniforms(env.fcolors, env.scolors ) ,
        targets  : new CompTargets( env.fcolors, env.scolors ) ,
    } ) ;

    env.scomp = new Abubu.Solver({
        fragmentShader : source('comp') ,
        uniforms : new CompUniforms(env.scolors, env.fcolors ) ,
        targets  : new CompTargets( env.scolors, env.fcolors ) ,
    } ) ;


/*========================================================================
 * surfaceVisualizer 
 *========================================================================
 */
    env.visurf = new Abubu.SurfaceVisualizer({
        canvas : canvas_1 ,
        target : env.fcolor0 ,
        structure : env.structure ,
        fovy : 0.51,
        rotation : [3.31,-3.14,2.29] ,
        lightDirection : [ 0.6,0.25,-2.06] ,
        lightSpecularTerm : 0.5, 
        lightAmbientTerm : 0.1, 
        materialSpecularTerm : 5.2 ,
        materialAmbientTerm : 0.1 ,
        shininess : 10 ,
        minValue : 0.1 ,
        maxValue : 0.7 ,
    } ) ;

/*========================================================================
 * signal plot 
 *========================================================================
 */
    // signal plot .......................................................
    env.signalplot = new Abubu.SignalPlot({
        noPltPoints : 1024,
        grid : 'on',
        nx : 5,
        ny : 10, 
        xticks : { mode: 'auto', unit : 'ms', font : '11pt Times'} ,
        yticks : { mode: 'auto', precision:1, unit : 'm', font : '11pt Times'} ,
        canvas : env.canvas_2 
    } ) ;

    env.voltageSignal = env.signalplot.addSignal( env.fcolor0 ,{
        channel : 'r', 
        minValue : 0. ,
        maxValue : 1. ,
        color :[0.5,0.,0.] ,
        restValue : 0 ,
        visible : true ,
        linewidth : 3,
        timeWindow: 1000 ,
        probePosition : [0.5,0.5] ,
    }) ;

    env.display = function(){
        env.visurf.render() ;

        //env.colorplot.time.text = env.time.toFixed(2) + ' [ms]' ;
        //env.colorplot.initForeground() ;
        //env.colorplot.render() ;
        env.signalplot.render() ;
    }

    // wall Timer ........................................................
    env.wallTimer = new WallTimer() ;

    // solve or pause simulations ........................................
    env.solveOrPause = function(){
        env.running = !env.running ;
        env.wallTimer.paused = !env.running ;

        if (env.running){
            //env.colorplot.status.text = 'Running...' ;
        }else{
            //env.colorplot.status.text = 'Paused!' ;
        }
    } 

    // initialize the solution using the solvers .........................
    env.init = function(){
        env.time = 0 ;
        env.wallTimer.reset() ;
        env.signalplot.init(env.time) ;
        env.finit.render() ;
        env.sinit.render() ;
        return ;
    }
    env.init() ;
    
/*------------------------------------------------------------------------
 * click
 *------------------------------------------------------------------------
 */
    env.click = new Abubu.Solver({
        fragmentShader : source( 'click' ) ,
        uniforms : {
            icolor0 : { type : 't', value : env.fcolor0 } ,
            compressed3dCrdt : { type : 't', 
                value : env.structure.compressed3dCrdt            } ,
            projectedCoordinates : { type : 't', 
                value : env.visurf.projectedCoordinates  } ,
            clickPosition : { type : 'v2', value : [0.,0] } ,
            clickRadius     : { type : 'f', value : 0.1 } ,
        } ,
        targets : {
            ocolor0 : { location : 0 , target : env.scolor0 } ,
        }
    } ) ;

    env.clickCopy = new Abubu.Copy( env.scolor0, env.fcolor0 ) ;
    
    env.cmndClick = new Abubu.CommandClickListener(
        canvas_1 , (e) =>{
            env.click.uniforms.clickPosition.value = e.position ;
            env.click.render() ;
            env.clickCopy.render() ;
        } , { mousemove : true  } 
    ) ;

    env.cntrlClick = new Abubu.CtrlClickListener(
        canvas_1 , (e) =>{
            env.click.uniforms.clickPosition.value = e.position ;
            env.click.render() ;
            env.clickCopy.render() ;
        } , { mousemove : true  } 
    ) ;

    env.shiftClick = new Abubu.ShiftClickListener(
        canvas_1,
        (e)=>{
            var clickCompPosition = 
            env.visurf.getCompressedClickPosition(e.position);
            env.signalplot.setProbePosition( clickCompPosition ) ;
            env.signalplot.init(env.time) ;
        } ) ;        

/*------------------------------------------------------------------------
 * editors
 *------------------------------------------------------------------------
 */
    env.editor = new Abubu.Editor({
        sources : {
            direction : {
                source : source('directionator') ,
                solvers: [ env.directionator ],
                title : 'direction' ,
                filename: 'directionator.frag' ,
            } ,
            comp : { 
                source : source('comp') , 
                solvers : [ env.fcomp, env.scomp ] ,
                title : 'comp' ,
                filename: 'comp.frag' ,
            } ,
            init : { 
                source : source('init') , 
                solvers : [ env.finit, env.sinit ] ,
                title : 'init' ,
                filename: 'init.frag' ,
            } ,
        } ,
        id : 'editor', 
        active: 'comp' ,
    } ) ;

    env.toggleEditor = function(){
        $("#editorSection").fadeToggle(300)
    } ;

/*------------------------------------------------------------------------
 * CanvasSaver 
 *------------------------------------------------------------------------
 */
    class CanvasSaver{
        constructor(canvas_id, opts={}){
            this.canvas = document.getElementById(canvas_id) ;
            this.link   = document.createElement('a') ;
            this.filename = canvas_id + '.png' ;
        }

        save(filename){
            if (filename){
                this.link.download = filename  ;
            }else{
                this.link.download = this.filename ;
            }
            this.link.href = this.canvas.toDataURL()  ;
            this.link.dispatchEvent(new MouseEvent('click',{
                'view' : window, 
                'bubbles': true ,
                'cancelable': false ,
            } ) ) ;
        }
    }

    env.saveColorplot = new CanvasSaver('canvas_1') ;

/*------------------------------------------------------------------------
 * Interval Caller
 *------------------------------------------------------------------------
 */
    class IntervalCaller{
        constructor(opts={}){
            this.interval = opts?.interval ?? 10 ;
            this.callback = opts?.callback ?? (()=>{}) ;
            this.time     = Infinity ;
            this.active   = opts?.active ?? false ;
            this.counter  = 0 ;
        }
        call(){
            this.time += env.dt*2. ;
            if (this.active){
                if (this.time >= this.interval){
                    this.callback() ;
                    this.counter++ ;
                    this.time = 0. ;
                }
            }
            return ;
        }
    }

    env.intervalCaller = new IntervalCaller({
        interval : 10 ,
        callback : ()=>{
            // env.display() ; this is not needed as operation is
            // completed after the screen is successfully refreshed.
            env.saveColorplot.save('vlt_'+
                    (env.intervalCaller.interval*
                     env.intervalCaller.counter).toFixed()
                    .toString()
                    .padStart(7,'0')+'.png') ;
        } ,
        active : false ,
    } ) ;

/*------------------------------------------------------------------------
 * createGui
 *------------------------------------------------------------------------
 */
   createGui() ;

/*------------------------------------------------------------------------
 * rendering the program ;
 *------------------------------------------------------------------------
 */
    env.render = function(){
        if (env.running){
            for(let i=0; i<env.skip; i++){
                env.wallTimer.measure() ;
                env.fcomp.render() ;
                env.scomp.render() ;
                env.time += env.dt*2. ;
                env.signalplot.update(env.time) ;
            }
        }
        env.display() ;
        requestAnimationFrame(env.render) ;
    }

/*------------------------------------------------------------------------
 * add environment to document
 *------------------------------------------------------------------------
 */
    document.env = env ;

/*------------------------------------------------------------------------
 * render the webgl program
 *------------------------------------------------------------------------
 */
    env.render();

}/*  End of loadWebGL  */

/*========================================================================
 * add multiple parameters to the GUI
 *========================================================================
 */ 
function addToGui( 
        guiElemenent ,  // gui element to add options into
        obj,            // object that holds parameters
        paramList,      // array of strings that contains list 
                        // of parmeters to be added
        solverList      // array of solvers that need to be update upon 
                        // change of a parameter through gui interactions
    ){
    let elements = {} ;
    for(let param of paramList){
        elements[param] = 
            guiElemenent.add(obj, param ).onChange( ()=> {
                Abubu.setUniformInSolvers( 
                    param, obj[param], solverList ) ;
            } ) ;
    }
    return elements ;
}
/*========================================================================
 * addVectorToGui
 *========================================================================
 */
function addVectorToGui(
    guiElem, 
    obj, 
    param , opts){
    let elems = [] ;
    let labels = opts?.labels ?? 'XYZW' ;

    for (var i=0 ; i< obj[param].length ; i++){
        elems.push(guiElem.add( obj[param] , i.toString() )
            .name( param + ' ' + labels[i] ) );
       elems[i].onChange( ()=>{ obj[param] = obj[param] } ) ;
        if ( opts?.callback ){
            elems[i].onChange( ()=>{ 
                    obj[param] = obj[param];
                    opts.callback();
                }   ) ;
        }

        if ( opts?.min ){
            elems[i].min( opts.min ) ;
        }
        if ( opts?.max ){
            elems[i].max( opts.max ) ;
        }
        if ( opts?.step ){
            elems[i].step( opts.step ) ;
        }
         
    }
    return elems ;
}
/*========================================================================
 * createGui
 *========================================================================
 */
function createGui(){
    env.gui = new Abubu.Gui() ;
    env.gui.pnl1 = env.gui.addPanel({width:300}) ;
    let pnl1 = env.gui.pnl1 ;
    
    // model .............................................................
    pnl1.f0 = pnl1.addFolder('Patient Info') ;
    pnl1.f0.add( env.patient , 'name', env.patient.list)
        .name('Patient Name').onChange(function(){
            pnl1.f0.updateDisplay() ;
            env.patient.updateSolvers() ;
        }) ;
    addToGui( pnl1.f0, env, env.allFloats, [env.fcomp,env.scomp] ) ;

    // wall-time measurements --------------------------------------------
    pnl1.f4 = pnl1.addFolder('Wall time measurements') ;
    pnl1.f4.add(env.wallTimer, 'duration').name('Sim. Activity [ms]') ; 
    pnl1.f4.add(env.wallTimer, 'progress').name("Progress [%]").listen() ;
    pnl1.f4.add(env.wallTimer, 'lapsedTime').name("Measured Walltime [ms]").listen() ; 
    pnl1.f4.add(env.wallTimer, 'reset').name('Reset') ; 

    // display -----------------------------------------------------------
    pnl1.f1 = pnl1.addFolder('Display') ;
    pnl1.visurf = env.visurf.controlByGui( pnl1.f1) ;

    pnl1.f1.add(env, 'skip' ) ;
    pnl1.f1.open() ;
    
    // source code editors ...............................................
    pnl1.f2  = pnl1.addFolder('Edit/Save/Load Source Code') ;
    pnl1.f2.add( env , 'toggleEditor').name('Show/Hide Editor' ) ;
    pnl1.f2.add( env.editor , 'title', env.editor.titles )
        .name('Edit source').onChange( ()=>{ pnl1.updateDisplay() ;} ) ;
    pnl1.f2.add( env.editor , 'filename').name('Filename') ;
    pnl1.f2.add( env.editor , 'save' ).name('Save to file') ;
    pnl1.f2.add( env.editor , 'load' ).name('Load from file') ;

    // simulation ........................................................
    pnl1.f3 = pnl1.addFolder('Simulation') ;
    pnl1.f3.add(env, 'init' ).name('Initialize Solution') ;
    pnl1.f3.add(env, 'solveOrPause').name('Solve/Pause') ;
    pnl1.f3.add(env, 'time').name('Solution Time [ms]').listen() ;
    pnl1.f3.open() ;
    return ;
} /* End of createGui */

/*========================================================================
 * WebXR session management
 *========================================================================
 */
let vrSupported = false;
let isVRActive = false;
let xrSession = null;
let xrRefSpace = null;
let vrRenderLoop = null;
let vrSurfaceVisualizer = null;
let vrControllers = [];
let isRotating = false;
let rotationSpeed = 0.02;

async function checkVRSupport() {
    try {
        // Check if WebXR is supported
        if ('xr' in navigator) {
            vrSupported = await navigator.xr.isSessionSupported('immersive-vr');
            console.log('Immersive VR supported:', vrSupported);
            
            if (vrSupported) {
                createVRButton();
            } else {
                console.log('VR not supported on this device');
            }
        } else {
            console.log('WebXR not supported in this browser');
        }
    } catch (error) {
        console.error('Error checking VR support:', error);
    }
}

function createVRButton() {
    const button = document.createElement('button');
    button.textContent = "Enter VR";
    button.style.position = 'fixed';
    button.style.bottom = '20px';
    button.style.left = '50%';
    button.style.transform = 'translateX(-50%)';
    button.style.zIndex = '1001';
    button.style.padding = '15px 30px';
    button.style.backgroundColor = '#4CAF50';
    button.style.color = 'white';
    button.style.border = 'none';
    button.style.borderRadius = '8px';
    button.style.cursor = 'pointer';
    button.style.fontSize = '16px';
    button.style.fontWeight = 'bold';
    button.style.boxShadow = '0 4px 8px rgba(0,0,0,0.3)';
    
    button.addEventListener('click', enterVR);
    document.body.appendChild(button);
}

// Create a VR-compatible surface visualizer
function createVRSurfaceVisualizer() {
    console.log('Creating VR surface visualizer using existing visurf...');
    
    // Instead of creating a new surface visualizer, use the existing one
    vrSurfaceVisualizer = env.visurf;
    
    // Update the existing visualizer for VR
    if (vrSurfaceVisualizer) {
        // Set VR-specific properties
        vrSurfaceVisualizer.fovy = 0.8; // Wider FOV for VR
        vrSurfaceVisualizer.translation = [0, 0, -3]; // Fixed position 3 units in front of origin
        
        // Ensure the surface visualizer has the correct target texture
        if (vrSurfaceVisualizer.target && env.fcolor0) {
            console.log('Setting VR surface visualizer target to fcolor0');
            vrSurfaceVisualizer.target = env.fcolor0;
        }
        
        // Ensure stereo rendering is enabled
        if (vrSurfaceVisualizer.surfaceView && vrSurfaceVisualizer.surfaceView.uniforms) {
            // Make sure the visualizer can handle different view matrices for each eye
            console.log('Setting up stereo rendering for VR...');
            
            // Force update of matrices to ensure they're properly initialized
            vrSurfaceVisualizer.updateViewMatrix();
            vrSurfaceVisualizer.updateNormalMatrix();
            
            // Make sure the surface view has the correct target
            if (vrSurfaceVisualizer.surfaceViewTarget) {
                vrSurfaceVisualizer.surfaceViewTarget.target = env.fcolor0;
            }
        }
        
        console.log('VR Surface Visualizer created from existing visurf');
        console.log('VR Surface Visualizer properties:', {
            fovy: vrSurfaceVisualizer.fovy,
            translation: vrSurfaceVisualizer.translation,
            rotation: vrSurfaceVisualizer.rotation,
            hasSurfaceView: !!vrSurfaceVisualizer.surfaceView,
            hasSurfaceViewTarget: !!vrSurfaceVisualizer.surfaceViewTarget,
            hasSurfaceViewBlend: !!vrSurfaceVisualizer.surfaceViewBlend,
            target: vrSurfaceVisualizer.target,
            viewMatrix: vrSurfaceVisualizer.viewMatrix,
            projectionMatrix: vrSurfaceVisualizer.projectionMatrix
        });
    } else {
        console.error('Failed to get existing surface visualizer');
    }
    
    return vrSurfaceVisualizer;
}

async function enterVR() {
    try {
        console.log('Attempting to enter VR...');
        
        // Check if heart structure is loaded
        if (!env.structure || !env.fcolor0) {
            console.error('Heart structure not loaded! Please load a JSON file first.');
            alert('Please load a heart structure file before entering VR.');
            return;
        }
        
        // Make the WebGL context XR compatible
        await gl.makeXRCompatible();
        console.log('WebGL context made XR compatible');
        
        // Request VR session with only supported features
        const sessionOptions = {
            optionalFeatures: ['local-floor']
        };
        
        xrSession = await navigator.xr.requestSession('immersive-vr', sessionOptions);
        console.log('VR session created');
        
        // Create XR layer
        const layer = new XRWebGLLayer(xrSession, gl);
        xrSession.updateRenderState({ baseLayer: layer });
        console.log('XR layer created');
        
        // Get reference space
        xrRefSpace = await xrSession.requestReferenceSpace('local');
        console.log('Reference space created');
        
        // Set up session event handlers
        xrSession.addEventListener('end', exitVR);
        xrSession.addEventListener('selectstart', onSelectStart);
        xrSession.addEventListener('selectend', onSelectEnd);
        xrSession.addEventListener('squeezestart', onSqueezeStart);
        xrSession.addEventListener('squeezeend', onSqueezeEnd);
        
        // Set up controller input sources
        xrSession.addEventListener('inputsourceschange', onInputSourcesChange);
        
        isVRActive = true;
        
        // Hide the webpage for immersive VR experience
        hideWebpageForVR();
        
        // Create VR surface visualizer
        console.log('Creating VR surface visualizer...');
        createVRSurfaceVisualizer();
        
        if (!vrSurfaceVisualizer) {
            throw new Error('Failed to create VR surface visualizer');
        }
        console.log('VR surface visualizer created successfully');
        
        // Pause the normal render loop
        if (env.running) {
            env.solveOrPause(); // Pause simulation
        }
        
        // Start the VR render loop
        console.log('Starting VR render loop...');
        vrRenderLoop = xrSession.requestAnimationFrame(renderVR);
        
        console.log('VR session started successfully');
        
    } catch (error) {
        console.error('Error entering VR:', error);
        isVRActive = false;
        alert('Failed to enter VR: ' + error.message);
    }
}

function renderVR(time, frame) {
    if (!isVRActive || !frame) {
        console.log('VR render loop stopped');
        return;
    }
    
    try {
        const pose = frame.getViewerPose(xrRefSpace);
        if (pose) {
            const layer = xrSession.renderState.baseLayer;
            
            console.log('VR frame processing, views:', pose.views.length);
            
            // Bind the XR framebuffer
            gl.bindFramebuffer(gl.FRAMEBUFFER, layer.framebuffer);
            console.log('XR framebuffer bound, dimensions:', layer.framebufferWidth, 'x', layer.framebufferHeight);
            
            // Clear the framebuffer with a visible background
            gl.clearColor(0.2, 0.2, 0.2, 1.0);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            // Handle controller input
            handleControllerInput(frame);
            
            // Debug: Check if heart structure exists
            if (!vrSurfaceVisualizer) {
                console.error('VR Surface Visualizer is null!');
                return;
            }
            
            // Loop through each of the views reported by the frame and draw them
            // into the corresponding viewport (this creates the stereo effect)
            console.log('Processing', pose.views.length, 'views for stereo rendering');
            
            // Test: Render both eyes to the full framebuffer to see if viewport splitting is the issue
            gl.viewport(0, 0, layer.framebufferWidth, layer.framebufferHeight);
            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
            
            console.log('Testing full framebuffer rendering for both eyes');
            
            // Render left eye content on the left side
            gl.viewport(0, 0, layer.framebufferWidth / 2, layer.framebufferHeight);
            updateVRCamera(pose.views[0], pose);
            renderSurfaceInVR();
            
            // Render right eye content on the right side  
            gl.viewport(layer.framebufferWidth / 2, 0, layer.framebufferWidth / 2, layer.framebufferHeight);
            updateVRCamera(pose.views[1], pose);
            renderSurfaceInVR();
            
            console.log('Full framebuffer test completed');
        } else {
            console.error('No pose available in VR render loop');
        }
        
        // Continue the VR render loop
        vrRenderLoop = xrSession.requestAnimationFrame(renderVR);
        
    } catch (error) {
        console.error('Error in VR render loop:', error);
        console.error('Error details:', error.stack);
        exitVR();
    }
}

function updateVRCamera(view, pose) {
    try {
        const viewMatrix = view.transform.matrix;
        const projectionMatrix = view.projectionMatrix;
        
        // Store the current eye for the render function
        updateVRCamera.currentEye = view.eye;
        
        if (vrSurfaceVisualizer) {
            // Set the projection matrix for this specific eye
            vrSurfaceVisualizer.projectionMatrix = projectionMatrix;
            if (vrSurfaceVisualizer.surfaceView && vrSurfaceVisualizer.surfaceView.uniforms) {
                vrSurfaceVisualizer.surfaceView.uniforms.projectionMatrix.value = projectionMatrix;
            }
            
            // Set the view matrix for this specific eye (this creates the stereo effect)
            vrSurfaceVisualizer.viewMatrix = viewMatrix;
            if (vrSurfaceVisualizer.surfaceView && vrSurfaceVisualizer.surfaceView.uniforms) {
                vrSurfaceVisualizer.surfaceView.uniforms.viewMatrix.value = viewMatrix;
            }
            
            // Update the normal matrix for proper lighting
            vrSurfaceVisualizer.updateNormalMatrix();
            
            // Debug logging - show the actual matrices for each eye
            console.log('Processing eye:', view.eye);
            console.log('View Matrix:', Array.from(viewMatrix));
            console.log('Projection Matrix:', Array.from(projectionMatrix));
            
            // Check if matrices are different between eyes (for stereo)
            if (!updateVRCamera.lastViewMatrix) {
                updateVRCamera.lastViewMatrix = new Float32Array(16);
                updateVRCamera.lastEye = view.eye;
            } else if (updateVRCamera.lastEye !== view.eye) {
                // Compare matrices between eyes
                let matricesDifferent = false;
                for (let i = 0; i < 16; i++) {
                    if (Math.abs(viewMatrix[i] - updateVRCamera.lastViewMatrix[i]) > 0.001) {
                        matricesDifferent = true;
                        break;
                    }
                }
                console.log('Matrices different between eyes:', matricesDifferent);
                updateVRCamera.lastViewMatrix = new Float32Array(viewMatrix);
                updateVRCamera.lastEye = view.eye;
            }
            
            // Reduced frequency logging
            if (Math.random() < 0.001) { 
                console.log('VR Heart Position:', vrSurfaceVisualizer.translation);
            }
        }
    } catch (error) {
        console.error('Error updating VR camera:', error);
    }
}

function renderSurfaceInVR() {
    try {
        console.log('Starting VR surface rendering...');
        
        // Check if we have the heart structure loaded
        if (!vrSurfaceVisualizer) {
            console.error('VR Surface Visualizer not available');
            return;
        }
        
        if (!env.structure) {
            console.error('Heart structure not loaded - please load a JSON file first');
            return;
        }
        
        console.log('Heart structure check:', {
            structureLoaded: !!env.structure,
            structureProperties: env.structure ? Object.keys(env.structure) : null,
            hasCompressed3dCrdt: !!(env.structure && env.structure.compressed3dCrdt),
            hasNormals: !!(env.structure && env.structure.normals),
            fcolor0Loaded: !!env.fcolor0
        });
        
        // Try to render the actual heart structure
        if (vrSurfaceVisualizer.surfaceView) {
            console.log('Rendering heart structure in VR...');
            console.log('Surface view properties:', {
                hasUniforms: !!vrSurfaceVisualizer.surfaceView.uniforms,
                uniforms: Object.keys(vrSurfaceVisualizer.surfaceView.uniforms || {}),
                target: vrSurfaceVisualizer.surfaceView.target,
                hasTarget: !!vrSurfaceVisualizer.surfaceView.target
            });
            
            // Update the surface visualizer matrices for this eye
            if (vrSurfaceVisualizer.surfaceView.uniforms) {
                vrSurfaceVisualizer.surfaceView.uniforms.viewMatrix.value = vrSurfaceVisualizer.viewMatrix;
                vrSurfaceVisualizer.surfaceView.uniforms.projectionMatrix.value = vrSurfaceVisualizer.projectionMatrix;
                vrSurfaceVisualizer.surfaceView.uniforms.normalMatrix.value = vrSurfaceVisualizer.normalMatrix;
                
                console.log('Matrices updated for eye:', updateVRCamera.currentEye);
            }
            
            // Set the target for the surface view if it doesn't have one
            if (!vrSurfaceVisualizer.surfaceView.target && env.fcolor0) {
                console.log('Setting surface view target to fcolor0');
                vrSurfaceVisualizer.surfaceView.target = env.fcolor0;
            }
            
            // Try to use the normal surface visualizer render method instead
            try {
                console.log('Trying normal surface visualizer render...');
                vrSurfaceVisualizer.render();
                console.log('Heart structure rendered for eye:', updateVRCamera.currentEye);
            } catch (renderError) {
                console.error('Error during normal surface visualizer render:', renderError);
                
                // Fallback to surface view render
                try {
                    console.log('Falling back to surface view render...');
                    vrSurfaceVisualizer.surfaceView.render();
                    console.log('Heart structure rendered for eye:', updateVRCamera.currentEye);
                } catch (surfaceViewError) {
                    console.error('Error during surface view render:', surfaceViewError);
                    throw surfaceViewError;
                }
            }
        } else {
            console.error('Surface view not available in VR visualizer');
            console.log('VR Surface Visualizer properties:', {
                hasSurfaceView: !!vrSurfaceVisualizer.surfaceView,
                hasSurfaceViewTarget: !!vrSurfaceVisualizer.surfaceViewTarget,
                hasSurfaceViewBlend: !!vrSurfaceVisualizer.surfaceViewBlend,
                target: vrSurfaceVisualizer.target,
                structure: !!env.structure
            });
            // Fallback to test cube
            renderSimpleStereoTest();
        }
        
    } catch (error) {
        console.error('Error rendering surface in VR:', error);
        console.error('Error stack:', error.stack);
        // Fallback to test cube if heart rendering fails
        renderSimpleStereoTest();
    }
}

function renderSimpleStereoTest() {
    // Create a simple shader program for testing stereo
    if (!renderSimpleStereoTest.program) {
        const vsSource = `#version 300 es
            precision highp float;
            in vec3 aPosition;
            uniform mat4 uProjectionMatrix;
            uniform mat4 uViewMatrix;
            uniform mat4 uModelMatrix;
            void main() {
                gl_Position = uProjectionMatrix * uViewMatrix * uModelMatrix * vec4(aPosition, 1.0);
            }`;
        
        const fsSource = `#version 300 es
            precision highp float;
            uniform vec3 uColor;
            out vec4 outColor;
            void main() {
                outColor = vec4(uColor, 1.0);
            }`;
        
        function compileShader(type, src) {
            const s = gl.createShader(type);
            gl.shaderSource(s, src);
            gl.compileShader(s);
            if (!gl.getShaderParameter(s, gl.COMPILE_STATUS)) {
                console.error('Shader compilation error:', gl.getShaderInfoLog(s));
            }
            return s;
        }
        
        const vs = compileShader(gl.VERTEX_SHADER, vsSource);
        const fs = compileShader(gl.FRAGMENT_SHADER, fsSource);
        const prog = gl.createProgram();
        gl.attachShader(prog, vs);
        gl.attachShader(prog, fs);
        gl.linkProgram(prog);
        
        if (!gl.getProgramParameter(prog, gl.LINK_STATUS)) {
            console.error('Program linking error:', gl.getProgramInfoLog(prog));
        }
        
        renderSimpleStereoTest.program = prog;
        renderSimpleStereoTest.aPosition = gl.getAttribLocation(prog, 'aPosition');
        renderSimpleStereoTest.uProjectionMatrix = gl.getUniformLocation(prog, 'uProjectionMatrix');
        renderSimpleStereoTest.uViewMatrix = gl.getUniformLocation(prog, 'uViewMatrix');
        renderSimpleStereoTest.uModelMatrix = gl.getUniformLocation(prog, 'uModelMatrix');
        renderSimpleStereoTest.uColor = gl.getUniformLocation(prog, 'uColor');
        renderSimpleStereoTest.buffer = gl.createBuffer();
        
        // Create a simple cube geometry
        const vertices = new Float32Array([
            // Front face
            -0.5, -0.5,  0.5,
             0.5, -0.5,  0.5,
             0.5,  0.5,  0.5,
            -0.5,  0.5,  0.5,
            // Back face
            -0.5, -0.5, -0.5,
             0.5, -0.5, -0.5,
             0.5,  0.5, -0.5,
            -0.5,  0.5, -0.5,
        ]);
        
        gl.bindBuffer(gl.ARRAY_BUFFER, renderSimpleStereoTest.buffer);
        gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);
    }
    
    gl.useProgram(renderSimpleStereoTest.program);
    
    // Create identity model matrix
    const modelMatrix = new Float32Array([
        1, 0, 0, 0,
        0, 1, 0, 0,
        0, 0, 1, 0,
        0, 0, -2, 1  // Move 2 units back
    ]);
    
    // Set matrices
    gl.uniformMatrix4fv(renderSimpleStereoTest.uProjectionMatrix, false, vrSurfaceVisualizer.projectionMatrix);
    gl.uniformMatrix4fv(renderSimpleStereoTest.uViewMatrix, false, vrSurfaceVisualizer.viewMatrix);
    gl.uniformMatrix4fv(renderSimpleStereoTest.uModelMatrix, false, modelMatrix);
    
    // Set color (different for each eye to test stereo)
    const currentEye = updateVRCamera.currentEye;
    const eyeColor = currentEye === 'left' ? [1, 0, 0] : [0, 1, 0]; // Red for left, green for right
    gl.uniform3fv(renderSimpleStereoTest.uColor, eyeColor);
    
    console.log('Rendering test cube for eye:', currentEye, 'color:', eyeColor);
    
    // Draw cube
    gl.bindBuffer(gl.ARRAY_BUFFER, renderSimpleStereoTest.buffer);
    gl.enableVertexAttribArray(renderSimpleStereoTest.aPosition);
    gl.vertexAttribPointer(renderSimpleStereoTest.aPosition, 3, gl.FLOAT, false, 0, 0);
    
    // Draw front and back faces
    gl.drawArrays(gl.TRIANGLE_FAN, 0, 4);
    gl.drawArrays(gl.TRIANGLE_FAN, 4, 4);
    
    gl.disableVertexAttribArray(renderSimpleStereoTest.aPosition);
    gl.useProgram(null);
}

function onInputSourcesChange(event) {
    for (const inputSource of event.added) {
        console.log('Controller connected:', inputSource.handedness);
        vrControllers.push(inputSource);
    }
    
    for (const inputSource of event.removed) {
        console.log('Controller disconnected:', inputSource.handedness);
        const index = vrControllers.indexOf(inputSource);
        if (index > -1) {
            vrControllers.splice(index, 1);
        }
    }
}

function onSelectStart(event) {
    console.log('VR select start');
    isRotating = true;
}

function onSelectEnd(event) {
    console.log('VR select end');
    isRotating = false;
}

function onSqueezeStart(event) {
    console.log('VR squeeze start');
    isRotating = true;
}

function onSqueezeEnd(event) {
    console.log('VR squeeze end');
    isRotating = false;
}

function hideWebpageForVR() {
    const body = document.body;
    const style = body.style;
    
    if (!body.dataset.originalBackground) {
        body.dataset.originalBackground = style.backgroundColor;
        body.dataset.originalColor = style.color;
    }
    
    // Hide webpage elements but keep GUI accessible
    const elementsToHide = document.querySelectorAll('h1, h2, h3, h4, p, table, .loaded, #chooser');
    elementsToHide.forEach(element => {
        if (!element.dataset.originalDisplay) {
            element.dataset.originalDisplay = element.style.display;
        }
        element.style.display = 'none';
    });
    
    // Position GUI for VR instead of hiding it
    if (env.gui && env.gui.domElement) {
        if (!env.gui.domElement.dataset.originalPosition) {
            env.gui.domElement.dataset.originalPosition = env.gui.domElement.style.position;
            env.gui.domElement.dataset.originalTop = env.gui.domElement.style.top;
            env.gui.domElement.dataset.originalRight = env.gui.domElement.style.right;
            env.gui.domElement.dataset.originalZIndex = env.gui.domElement.style.zIndex;
            env.gui.domElement.dataset.originalBackground = env.gui.domElement.style.backgroundColor;
            env.gui.domElement.dataset.originalColor = env.gui.domElement.style.color;
            env.gui.domElement.dataset.originalBorder = env.gui.domElement.style.border;
            env.gui.domElement.dataset.originalBorderRadius = env.gui.domElement.style.borderRadius;
            env.gui.domElement.dataset.originalPadding = env.gui.domElement.style.padding;
            env.gui.domElement.dataset.originalMaxHeight = env.gui.domElement.style.maxHeight;
            env.gui.domElement.dataset.originalOverflowY = env.gui.domElement.style.overflowY;
        }
        
        // Position GUI for VR
        env.gui.domElement.style.position = 'fixed';
        env.gui.domElement.style.top = '20px';
        env.gui.domElement.style.right = '20px';
        env.gui.domElement.style.zIndex = '1000';
        env.gui.domElement.style.backgroundColor = 'rgba(0, 0, 0, 0.8)';
        env.gui.domElement.style.color = 'white';
        env.gui.domElement.style.border = '1px solid #444';
        env.gui.domElement.style.borderRadius = '5px';
        env.gui.domElement.style.padding = '10px';
        env.gui.domElement.style.maxHeight = '80vh';
        env.gui.domElement.style.overflowY = 'auto';
        env.gui.domElement.style.display = 'block';
        
        // Make GUI text more readable in VR
        const guiTexts = env.gui.domElement.querySelectorAll('*');
        guiTexts.forEach(element => {
            if (element.style) {
                element.style.color = 'white';
                element.style.fontSize = '14px';
            }
        });
    }
    
    style.backgroundColor = '#000000';
    style.color = '#ffffff';
    
    console.log('Webpage hidden for VR, GUI positioned for VR');
}

function showWebpageAfterVR() {
    const body = document.body;
    const style = body.style;
    
    if (body.dataset.originalBackground) {
        style.backgroundColor = body.dataset.originalBackground;
        delete body.dataset.originalBackground;
    }
    if (body.dataset.originalColor) {
        style.color = body.dataset.originalColor;
        delete body.dataset.originalColor;
    }
    
    const elementsToShow = document.querySelectorAll('h1, h2, h3, h4, p, table, .loaded, #chooser');
    elementsToShow.forEach(element => {
        if (element.dataset.originalDisplay !== undefined) {
            element.style.display = element.dataset.originalDisplay;
            delete element.dataset.originalDisplay;
        }
    });
    
    // Restore original GUI styling
    if (env.gui && env.gui.domElement) {
        if (env.gui.domElement.dataset.originalPosition !== undefined) {
            env.gui.domElement.style.position = env.gui.domElement.dataset.originalPosition;
            env.gui.domElement.style.top = env.gui.domElement.dataset.originalTop;
            env.gui.domElement.style.right = env.gui.domElement.dataset.originalRight;
            env.gui.domElement.style.zIndex = env.gui.domElement.dataset.originalZIndex;
            env.gui.domElement.style.backgroundColor = env.gui.domElement.dataset.originalBackground;
            env.gui.domElement.style.color = env.gui.domElement.dataset.originalColor;
            env.gui.domElement.style.border = env.gui.domElement.dataset.originalBorder;
            env.gui.domElement.style.borderRadius = env.gui.domElement.dataset.originalBorderRadius;
            env.gui.domElement.style.padding = env.gui.domElement.dataset.originalPadding;
            env.gui.domElement.style.maxHeight = env.gui.domElement.dataset.originalMaxHeight;
            env.gui.domElement.style.overflowY = env.gui.domElement.dataset.originalOverflowY;
            
            // Clear stored values
            delete env.gui.domElement.dataset.originalPosition;
            delete env.gui.domElement.dataset.originalTop;
            delete env.gui.domElement.dataset.originalRight;
            delete env.gui.domElement.dataset.originalZIndex;
            delete env.gui.domElement.dataset.originalBackground;
            delete env.gui.domElement.dataset.originalColor;
            delete env.gui.domElement.dataset.originalBorder;
            delete env.gui.domElement.dataset.originalBorderRadius;
            delete env.gui.domElement.dataset.originalPadding;
            delete env.gui.domElement.dataset.originalMaxHeight;
            delete env.gui.domElement.dataset.originalOverflowY;
        }
        
        // Restore original text colors
        const guiTexts = env.gui.domElement.querySelectorAll('*');
        guiTexts.forEach(element => {
            if (element.style) {
                element.style.color = '';
                element.style.fontSize = '';
            }
        });
    }
    
    console.log('Webpage restored after VR');
}

function handleControllerInput(frame) {
    if (!vrSurfaceVisualizer) return;
    
    if (isRotating) {
        const currentRotation = vrSurfaceVisualizer.rotation;
        currentRotation[1] += rotationSpeed;
        
        vrSurfaceVisualizer.rotation = currentRotation;
        
        if (env.visurf) {
            env.visurf.rotation = [...currentRotation];
        }
    }
    
    if (vrControllers.length > 0) {
        for (const inputSource of vrControllers) {
            try {
                let inputPose = null;
                
                if (frame.getInputSourcePose) {

                    inputPose = frame.getInputSourcePose(inputSource, xrRefSpace);
                } else if (frame.getInputPose) {
                    inputPose = frame.getInputPose(inputSource, xrRefSpace);
                }
                
                if (inputPose) {
                    // occasional logging
                    if (Math.random() < 0.01) {
                        const gripMatrix = inputPose.gripMatrix;
                        console.log('Controller position:', gripMatrix);
                    }
                }
            } catch (error) {
                console.log('no controller')
            }
        }
    }
}

function exitVR() {
    console.log('Exiting VR...');
    
    isVRActive = false;
    
    showWebpageAfterVR();
    
    if (vrSurfaceVisualizer) {
        vrSurfaceVisualizer = null;
    }
    
    if (xrSession) {
        xrSession.end();
    }
    
    xrSession = null;
    xrRefSpace = null;
    vrRenderLoop = null;
    
    if (env.render) {
        requestAnimationFrame(env.render);
    }
    
    console.log('VR session ended');
}

checkVRSupport();

const originalRender = env.render;
env.render = function() {
    if (isVRActive) {
        return;
    }
    
    originalRender.call(this);
};

function addVRControlsToGUI() {
    if (env.gui && env.gui.pnl1) {
        env.gui.pnl1.f5 = env.gui.pnl1.addFolder('Virtual Reality');
        env.gui.pnl1.f5.add({ enterVR: enterVR }, 'enterVR').name('Enter VR');
        env.gui.pnl1.f5.add({ exitVR: exitVR }, 'exitVR').name('Exit VR');
        env.gui.pnl1.f5.add({ isVRActive: () => isVRActive }, 'isVRActive').name('VR Active').listen();
        
        // VR Interaction controls
        env.gui.pnl1.f5.f1 = env.gui.pnl1.f5.addFolder('VR Interaction');
        env.gui.pnl1.f5.f1.add({ rotationSpeed: rotationSpeed }, 'rotationSpeed', 0.001, 0.1, 0.001)
            .name('Rotation Speed').onChange((value) => { rotationSpeed = value; });
        env.gui.pnl1.f5.f1.add({ isRotating: () => isRotating }, 'isRotating').name('Currently Rotating').listen();
        env.gui.pnl1.f5.f1.add({ controllerCount: () => vrControllers.length }, 'controllerCount').name('Controllers Connected').listen();
    }
}

setTimeout(addVRControlsToGUI, 1000);

</script>


</body>
</html>

